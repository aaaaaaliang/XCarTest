一、Ping 检查需求
1. 外部 Ping（从 Host）
（不用顺序执行，最终能ping通就行）我目前是windows 不用兼容linux，不要误判 我认为这个ping成功 响应的数据很有特点的
192.168.1.99
192.168.1.9
192.168.1.1
192.168.1.201
192.168.1.202

2. 主模组内部 Ping（SSH 到 192.168.1.201）
（不用顺序执行，最终能ping通就行）
严格顺序执行：
192.168.1.99
192.168.1.9
192.168.1.1
192.168.1.201
192.168.1.202
14.103.165.189

3. 副模组内部 Ping（SSH 到 192.168.1.202）
（不用顺序执行，最终能ping通就行）  
192.168.1.99
192.168.1.9
192.168.1.1
192.168.1.201
192.168.1.202
14.103.165.189

4. 结果要求
每个 IP 必须在结果里体现 PASS / FAIL。
同时记录 尝试次数 + 首次打通时间 (first_ok_s)，如果你是并行ping那统计有意义，不是并行就不统计看你
如果 SSH 失败 → 模组内所有 IP 统一标记 FAIL。（ssh连接 当电流>400的时候 120s没连上 就判断位连不上了）

二、休眠判定需求
1. 判据
监听 OUT_TX 报文（0x5A0、0x603、0x6C0、0x6C1）。（这个日志一直有 因为这几个外发过多 两个方案 一个是给出日志过滤脚本  一个就是尽量优化日志）
判定条件：连续静默 ≥ SLEEP_SILENCE_S 秒。
最长等待 SLEEP_MAX_WAIT_S 秒，超时则 TIMEOUT。

2. 关注的两个指标（这两个指标可以）
stop→last_tx_seen_s：停发唤醒帧（0x795）到最后一次见到 OUT_TX 的时间。
sleep_reached_s：真正满足静默窗口后，确认进入休眠所需的时间（严格的休眠达成时间）。

三、日志与输出需求
1. 控制台输出

分三个区块打印：
外部 Ping
主模组内 Ping
副模组内 Ping
每个区块逐 IP 一行，格式类似：
192.168.1.99     PASS ✅  尝试14  首通 0.016s
192.168.1.9      FAIL ❌  尝试56  未打通

额外一个区块：休眠判定结果（状态 + 两个时间指标）。

2. CSV 摘要
原有字段：host_first_ok_s / main_first_ok_s / backup_first_ok_s / …
新增三列：
host_pass_map （JSON: {ip: true/false}）
main_pass_map
backup_pass_map
notes 字段保留详细信息（计数器、first_ok_map、错误信息等）。

四、重试与增强机制
1. SSH 连接
指数退避 + 抖动 (jitter)。
总预算时间：SSH_CONNECT_TOTAL_BUDGET_S 秒（迟到上线补采窗口）。
成功后立即执行模组内 Ping 并记录到同一条 CSV。

2. Ping 重试
模式可选：
fast → 首次成功立即返回。
full → 统计整个窗口。
每个 IP 持续尝试直到超时或成功。

3. 电流判据（可选）
休眠时：电流 < POWER_WAKE_THRESHOLD_MA 且保持 ≥ POWER_HOLD_MS。
唤醒时：电流 > 阈值，超时则报 WARN。

4. 唤醒策略
唤醒报文：周期发送 0x795。
可选固定等待（如 60s）或随机等待（WAKE_RANDOM_ENABLED）。 
